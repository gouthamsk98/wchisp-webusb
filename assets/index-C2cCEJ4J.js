var R=Object.defineProperty;var S=(o,t,i)=>t in o?R(o,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):o[t]=i;var a=(o,t,i)=>S(o,typeof t!="symbol"?t+"":t,i);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))e(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const s of r.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&e(s)}).observe(document,{childList:!0,subtree:!0});function i(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function e(n){if(n.ep)return;n.ep=!0;const r=i(n);fetch(n.href,r)}})();class D{static responseToString(t){switch(t.type){case"Ok":return`OK[${Buffer.from(t.data).toString("hex")}]`;case"Err":return`ERROR(${t.code.toString(16)})[${Buffer.from(t.data).toString("hex")}]`}}static isOk(t){return t.type==="Ok"}static payload(t){return t.type==="Ok",t.data}static fromRaw(t){const i=new DataView(t.buffer).getUint16(2,!0),e=t.subarray(4);return e.length===i?{type:"Ok",data:e}:{type:"Err",code:t[1],data:t.subarray(2)}}}const h=class h{constructor(t){a(this,"device");this.device=t}static debugLog(t){const i=document.querySelector("#console");i.value+=t+`
`,i.scrollTop=i.scrollHeight}static clearLog(){const t=document.querySelector("#console");t.value=""}static async scanDevices(){const t=[{vendorId:17224,productId:21984},{vendorId:6790,productId:21984}],e=(await navigator.usb.getDevices()).filter(n=>t.some(r=>n.vendorId===r.vendorId&&n.productId===r.productId));return console.debug(`Found ${e.length} WCH ISP USB devices`),e.length}static async openNth(t){const e=(await navigator.usb.getDevices())[t];if(!e)throw new Error(`No WCH ISP USB device found (4348:55e0 or 1a86:55e0 device not found at index #${t})`);console.debug(`Found USB Device ${e.productName}`),await e.open(),e.configuration===null&&await e.selectConfiguration(1);const n=e.configuration;let r=!1,s=!1;if(n){console.log("config",n);for(const c of n.interfaces){console.log(c);for(const l of c.alternate.endpoints)l.endpointNumber===this.ENDPOINT_OUT&&(r=!0),l.endpointNumber===this.ENDPOINT_IN&&(s=!0)}}if(!(r&&s))throw new Error("USB Endpoints not found");return await e.claimInterface(0),new h(e)}static async openAny(){return this.openNth(0)}async sendRaw(t){await this.device.transferOut(h.ENDPOINT_OUT,t)}async recvRaw(){const t=await this.device.transferIn(h.ENDPOINT_IN,64);if(t.data)return new Uint8Array(t.data.buffer);throw new Error("Failed to receive data")}async recv(){const t=await this.device.transferIn(h.ENDPOINT_IN,64);if(t.data)return D.fromRaw(new Uint8Array(t.data.buffer));throw new Error("Failed to receive data")}};a(h,"ENDPOINT_OUT",2),a(h,"ENDPOINT_IN",2),a(h,"USB_TIMEOUT_MS",5e3),a(h,"MAX_PACKET_SIZE",64),a(h,"SECTOR_SIZE",1024),a(h,"DEFAULT_TRANSPORT_TIMEOUT_MS",1e3);let E=h;class F{constructor(){a(this,"IDENTIFY",161);a(this,"ISP_END",162);a(this,"ISP_KEY",163);a(this,"ERASE",164);a(this,"PROGRAM",165);a(this,"VERIFY",166);a(this,"READ_CONFIG",167);a(this,"WRITE_CONFIG",168);a(this,"DATA_ERASE",169);a(this,"DATA_PROGRAM",170);a(this,"DATA_READ",171);a(this,"WRITE_OTP",195);a(this,"READ_OTP",196);a(this,"SET_BAUD",197)}async pwriteWith(t,i,e,n){if(typeof i=="number")t.setUint32(e,i,n);else for(let r=0;r<i.length;r++)t.setUint8(e+r,i[r]);return t}async ntoRaw(t){switch(t.type){case"Identify":{const{deviceId:i,deviceType:e}=t,n=new Uint8Array(21);return n[0]=this.IDENTIFY,n[1]=18,n[2]=0,n[3]=i,n[4]=e,n.set(new TextEncoder().encode("MCU ISP & WCH.CN"),5),n}case"IspEnd":{const{reason:i}=t;return new Uint8Array([this.ISP_END,1,0,i])}case"IspKey":{const{key:i}=t,e=new Uint8Array(3+i.length);return e[0]=this.ISP_KEY,e[1]=i.length,e[2]=0,e.set(i,3),e}case"Erase":{const{sectors:i}=t,e=new Uint8Array(7);return e[0]=this.ERASE,e[1]=4,e[2]=0,this.pwriteWith(new DataView(e.buffer),i,3,!0),e}case"Program":{const{address:i,padding:e,data:n}=t,r=new Uint8Array(8+n.length),s=new DataView(r.buffer);s.setUint8(0,this.PROGRAM),s.setUint32(3,i,!0),s.setUint8(7,e),r.set(n,8);const c=r.length-3;return s.setUint16(1,c,!0),new Uint8Array(s.buffer)}case"Verify":{const{address:i,padding:e,data:n}=t,r=new Uint8Array(8+n.length);r[0]=this.VERIFY,this.pwriteWith(new DataView(r.buffer),i,3,!0),r[7]=e,r.set(n,8);const s=r.length-3;return this.pwriteWith(new DataView(r.buffer),s,1,!0),r}case"ReadConfig":{const{bitMask:i}=t;return new Uint8Array([this.READ_CONFIG,2,0,i,0])}case"WriteConfig":{const{bitMask:i,data:e}=t,n=new Uint8Array(5+e.length);return n[0]=this.WRITE_CONFIG,this.pwriteWith(new DataView(n.buffer),1+e.length,1,!0),n[3]=i,n.set(e,5),n}case"DataRead":{const{address:i,len:e}=t,n=new Uint8Array(9);return n[0]=this.DATA_READ,n[1]=6,this.pwriteWith(new DataView(n.buffer),i,3,!0),this.pwriteWith(new DataView(n.buffer),e,7,!0),n}case"DataProgram":{const{address:i,padding:e,data:n}=t,r=new Uint8Array(8+n.length);r[0]=this.DATA_PROGRAM,this.pwriteWith(new DataView(r.buffer),i,3,!0),r[7]=e,r.set(n,8);const s=r.length-3;return this.pwriteWith(new DataView(r.buffer),s,1,!0),r}case"DataErase":{const{sectors:i}=t;return new Uint8Array([this.DATA_ERASE,5,0,0,0,0,0,i])}default:throw new Error("Unimplemented command")}}}const A="CH32X03x Series",I="0x13",v="0x23",T=!1,x=!0,C=!0,P="CH32X03x RISC-V4C Series",O=[{offset:"0x00",name:"RDPR_USER",description:"RDPR, nRDPR, USER, nUSER",reset:"0xFFFF5AA5",fields:[{bit_range:[7,0],name:"RDPR",description:"Read Protection. 0xA5 for unprotected, otherwise read-protected(ignoring WRP)",explaination:{"0xa5":"Unprotected",_:"Protected"}},{bit_range:[16,16],name:"IWDG_SW",description:"Independent watchdog (IWDG) hardware enable",explaination:{0:"IWDG enabled by the software (decided along with the LSI clock)",1:"IWDG enabled by the software, and disabled by hardware"}},{bit_range:[17,17],name:"STOP_RST",description:"System reset control under the stop mode",explaination:{0:"Enable",1:"Disable"}},{bit_range:[18,18],name:"STANDBY_RST",description:"System reset control under the standby mode, STANDY_RST",explaination:{0:"Enable",1:"Disable, entering standby-mode without RST"}},{bit_range:[20,19],name:"RST_MOD",description:"Reset mode",explaination:{"0b00":"Enable RST alternative function","0b11":"Disable RST alternative function, use PA21/PC3/PB7 as GPIO",_:"Error"}}]},{offset:"0x04",name:"DATA",description:"Customizable 2 byte data, DATA0, nDATA0, DATA1, nDATA1",reset:"0xFF00FF00",type:"u32",fields:[{bit_range:[7,0],name:"DATA0"},{bit_range:[23,16],name:"DATA1"}]},{offset:"0x08",name:"WRP",description:"Flash memory write protection status",type:"u32",reset:"0xFFFFFFFF",explaination:{"0xFFFFFFFF":"Unprotected",_:"Some 4K sections are protected"}}],L=[{name:"CH32X035R8T6",chip_id:80,flash_size:65536},{name:"CH32X035C8T6",chip_id:81,flash_size:65536},{name:"CH32X035F8U6",chip_id:94,flash_size:65536},{name:"CH32X035G8U6",chip_id:86,flash_size:65536},{name:"CH32X035G8R6",chip_id:91,flash_size:65536},{name:"CH32X035F7P6",chip_id:87,flash_size:49152}],U={name:A,mcu_type:I,device_type:v,support_net:T,support_usb:x,support_serial:C,description:P,config_registers:O,variants:L},N="CH59x Series",M="0x12",W="0x22",G=!0,k=!0,V=!1,H="CH59x (RISC-V4C BLE 5.4) Series",$=[{offset:"0x00",name:"RESERVED",description:"Reserved 32-bit word",reset:"0xFFFFFFFF",type:"u32"},{offset:"0x04",name:"WPROTECT",reset:"0xFFFFFFFF",type:"u32",fields:[{bit_range:[0,0],name:"NO_KEY_SERIAL_DOWNLOAD",description:"Turn on No-key serial port download",explaination:{0:"Disable",1:"Enable"}},{bit_range:[1,1],name:"DOWNLOAD_CFG",explaination:{0:"PB11",1:"PB22 (Default set)"}}]},{offset:"0x08",name:"USER_CFG",description:"User config register",reset:"0x4FFF0FD5",type:"u32",fields:[{bit_range:[2,0],name:"RESERVED",explaination:{"0b101":"Default",_:"Error"}},{bit_range:[3,3],name:"CFG_RESET_EN",description:"RST# external manual reset input pin enable",explaination:{0:"Disable",1:"Enable"}},{bit_range:[4,4],name:"CFG_DEBUG_EN",description:"Two-wire simulation debug interface SWD enable",explaination:{0:"Disable",1:"Enable"}},{bit_range:[5,5],name:"RESERVED",explaination:{0:"Default",_:"Error"}},{bit_range:[6,6],name:"CFG_BOOT_EN",description:"Bootloader enable",explaination:{0:"Disable",1:"Enable"}},{bit_range:[7,7],name:"CFG_ROM_READ",description:"Code and data protection mode in FlashROM",explaination:{0:"Disable the programmer to read out, and keep the program secret",1:"Read enable"}},{bit_range:[27,8],name:"RESERVED",explaination:{"0xFF0F":"Default",_:"Error"}},{bit_range:[31,28],name:"VALID_SIG",description:"Configuration information valid flag, fixed value",explaination:{"0b0100":"Valid",_:"Error"}}]}],z=[{name:"CH591",chip_id:145,flash_size:196608,eeprom_size:32768},{name:"CH592",chip_id:146,flash_size:458752,eeprom_size:32768}],B={name:N,mcu_type:M,device_type:W,support_usb:G,support_serial:k,support_net:V,description:H,config_registers:$,variants:z},d=class d extends E{constructor(i){super(i);a(this,"SECTOR_SIZE",1024);a(this,"device_type",null);a(this,"chip_id",null);a(this,"chip_uid",new Uint8Array(8));a(this,"code_flash_protected",null);a(this,"btver",new Uint8Array(4));a(this,"flash_size",null);a(this,"protocol",new F)}supportCodeFlashProtect(){return this.device_type?[20,21,23,24,25,32].includes(this.device_type):!1}minEraseSectorNumber(){return this.device_type===16?4:8}xorKey(){if(this.chip_id==null)throw new Error("Chip ID not found");const i=this.chip_uid.reduce((n,r)=>n+r,0)&255,e=new Uint8Array(8).fill(i);return e[7]=e[7]+this.chip_id&255,e}async findDevice(){d.clearLog();const i={type:"Identify",deviceId:0,deviceType:0},e=await this.protocol.ntoRaw(i);this.sendRaw(e);const n=await this.recv();if(n.type=="Err")throw new Error("Error in finding device");this.device_type=n.data[1],this.chip_id=n.data[0];let r;switch(this.device_type){case 34:r=B;break;case 35:r=U;break;default:throw new Error("Device not supported")}r.device_type=="0x"+this.device_type.toString(16)&&d.debugLog("Device Series : "+r.name),r.variants.forEach(u=>{u.chip_id==this.chip_id&&(this.flash_size=u.flash_size,d.debugLog("Chip : "+u.name),d.debugLog("Flash Size : "+u.flash_size/1024+" KiB"))});const s={type:"ReadConfig",bitMask:d.CFG_MASK_ALL},c=await this.protocol.ntoRaw(s);this.sendRaw(c);const l=await this.recv();if(l.type=="Err")throw new Error("Error in finding config");this.code_flash_protected=this.supportCodeFlashProtect()&&l.data[2]!=165,d.debugLog("Code Flash Protected : "+this.code_flash_protected),this.btver.set(l.data.slice(14,18)),d.debugLog("Bootloader Version (BTVER) : "+this.btver[0]+this.btver[1]+"."+this.btver[2]+this.btver[3]),this.chip_uid.set(l.data.slice(18)),d.debugLog("Chip UID : "+Array.from(this.chip_uid).map(u=>u.toString(16).padStart(2,"0").toUpperCase()).join("-")),this.dumpInfo(l,r)}async dumpInfo(i,e){const n=i.data.slice(2);e.config_registers.forEach(r=>{let s=new DataView(n.buffer,n.byteOffset+Number(r.offset),4).getUint32(0,!0);d.debugLog(r.name+" : 0x"+s.toString(16)),r.fields&&r.fields.forEach(c=>{let l=c.bit_range[0]-c.bit_range[1]+1,u=s>>>c.bit_range[1]&(1<<l)-1;if(d.debugLog(`[${c.bit_range[0]}, ${c.bit_range[1]}] ${c.name}  0x${u.toString(16)} (0b${u.toString(2)})`),"explaination"in c&&c.explaination)for(const[g,f]of Object.entries(c.explaination))u==Number(g)&&d.debugLog(` - ${f}`)})})}async eraseFlash(i=this.flash_size){if(this.flash_size||(await this.findDevice(),i=this.flash_size),!i)throw new Error("Flash size not found");let e=i/1024;const n=this.minEraseSectorNumber();e<n&&(e=n,d.debugLog(`erase_code: set min number of erased sectors to ${e}`));const r={type:"Erase",sectors:e},s=await this.protocol.ntoRaw(r);this.sendRaw(s),console.log(s);const c=await this.recv();if(console.log(c),c.type=="Err")throw new Error("Error in erasing flash");d.debugLog(`Erased ${e} code flash sectors`)}async flashChunk(i,e,n){const r=e.map((g,f)=>g^n[f%8]),s=Math.floor(Math.random()*256),c={type:"Program",address:i,padding:s,data:r},l=await this.protocol.ntoRaw(c);if(this.sendRaw(l),(await this.recv()).type=="Err")throw new Error(`Program 0x${i.toString(16).padStart(8,"0")} failed`);d.debugLog("Programmed 0x"+i.toString(16).padStart(8,"0"))}intelHexToUint8Array(i){const e=i.trim().split(`
`),n=[];return e.forEach(r=>{if(r.startsWith(":")){const s=parseInt(r.substr(1,2),16),c=9,l=c+s*2;for(let u=c;u<l;u+=2)n.push(parseInt(r.substr(u,2),16))}}),new Uint8Array(n)}async flashFirmware(i){const e=this.intelHexToUint8Array(i),n=e.length/this.SECTOR_SIZE+1;!this.chip_id&&!this.chip_uid&&await this.findDevice(),await this.eraseFlash(n);const r=this.xorKey(),s=r.reduce((w,_)=>w+_&255,0);console.log("key ",r,s);const c={type:"IspKey",key:new Uint8Array(30)},l=await this.protocol.ntoRaw(c);this.sendRaw(l);const u=await this.recv();if(u.type=="Err")throw new Error("isp_key failede");if(u.data[0]!=s)throw new Error("isp_key checksum failed");console.log("res data",u.data);const g=56;let f=0;for(let w=0;w<e.length;w+=g){const _=e.subarray(w,w+g);await this.flashChunk(f,_,r),f+=_.length}await this.flashChunk(f,new Uint8Array,r),d.debugLog("firmware flashed")}async reset(){const i={type:"IspEnd",reason:1},e=await this.protocol.ntoRaw(i);if(this.sendRaw(e),(await this.recv()).type=="Err")throw new Error("Error in reset");d.debugLog("Device Reset")}};a(d,"CFG_MASK_RDPR_USER_DATA_WPR",7),a(d,"CFG_MASK_BTVER",8),a(d,"CFG_MASK_UID",16),a(d,"CFG_MASK_CODE_FLASH_PROTECT",32),a(d,"CFG_MASK_ALL",31);let p=d,b=!1,y,m;const K=[{vendorId:17224,productId:21984},{vendorId:6790,productId:21984}];function q(o){o.addEventListener("click",()=>{navigator.usb.requestDevice({filters:K}).then(async t=>{y=new p(t),p.openNth(0),p.debugLog("Connected"),b=!b,o.innerHTML="Disconnect"}).catch(t=>{console.error(t),o.innerHTML="Connect"})})}function X(o){o.addEventListener("click",async()=>{if(!b){p.debugLog("Please Connect First");return}if(!y){p.debugLog("Something went wrong");return}try{await y.findDevice()}catch(t){p.debugLog(t)}})}function Y(o){o.addEventListener("click",async()=>{if(!b){p.debugLog("Please Connect First");return}o.innerHTML="Erasing...",await y.eraseFlash(),o.innerHTML="Erase"})}function Z(o){o.addEventListener("click",async()=>{if(!b){p.debugLog("Please Connect First");return}o.innerHTML="Flashing...",await y.flashFirmware(m),o.innerHTML="Flash"})}function j(o){o.addEventListener("click",async()=>{if(!b){p.debugLog("Please Connect First");return}o.innerHTML="Resetting...",await y.reset(),o.innerHTML="Reset"})}function J(o){return new Promise((t,i)=>{const e=new FileReader;e.onload=()=>t(e.result),e.onerror=i,e.readAsText(o)})}function Q(o){o.addEventListener("change",async t=>{const i=t.target.files[0];i&&i.name.endsWith(".hex")?(m=await J(i),console.log(m)):alert("Please upload a valid .hex file")})}document.querySelector("#app").innerHTML=`
  <div>
      <h1>WCH ISP Tool (only supported in chrome & edge )</h1>
      <button id="connect" type="button">Connect</button>
      <button id="getInfo" type="button">Get Info</button>
      <label for="myfile">Upload a hex:</label>
      <input type="file" id="myfile" name="myfile" accept=".hex">
      <button id="erase" type="button">Erase</button>
      <button id="flash" type="button">Flash</button>
      <button id="reset" type="button">Reset</button>
      <textarea id="console" rows="15" cols="50" readonly></textarea>
  </div>
`;q(document.querySelector("#connect"));Y(document.querySelector("#erase"));Z(document.querySelector("#flash"));X(document.querySelector("#getInfo"));Q(document.querySelector("#myfile"));j(document.querySelector("#reset"));
