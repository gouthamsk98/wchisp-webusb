var S=Object.defineProperty;var R=(c,s,e)=>s in c?S(c,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[s]=e;var o=(c,s,e)=>R(c,typeof s!="symbol"?s+"":s,e);(function(){const s=document.createElement("link").relList;if(s&&s.supports&&s.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))t(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&t(i)}).observe(document,{childList:!0,subtree:!0});function e(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function t(n){if(n.ep)return;n.ep=!0;const r=e(n);fetch(n.href,r)}})();class D{static responseToString(s){switch(s.type){case"Ok":return`OK[${Buffer.from(s.data).toString("hex")}]`;case"Err":return`ERROR(${s.code.toString(16)})[${Buffer.from(s.data).toString("hex")}]`}}static isOk(s){return s.type==="Ok"}static payload(s){return s.type==="Ok",s.data}static fromRaw(s){const e=new DataView(s.buffer).getUint16(2,!0),t=s.subarray(4);return t.length===e?{type:"Ok",data:t}:{type:"Err",code:s[1],data:s.subarray(2)}}}const p=class p{constructor(s){o(this,"device");this.device=s}async sleep(s){return new Promise(e=>setTimeout(e,s/1e3))}static debugLog(s){const e=document.querySelector("#console");e.value+=s+`
`,e.scrollTop=e.scrollHeight}static clearLog(){const s=document.querySelector("#console");s.value=""}static async scanDevices(){const s=[{vendorId:17224,productId:21984},{vendorId:6790,productId:21984}],t=(await navigator.usb.getDevices()).filter(n=>s.some(r=>n.vendorId===r.vendorId&&n.productId===r.productId));return console.debug(`Found ${t.length} WCH ISP USB devices`),t.length}static async openNth(s){const t=(await navigator.usb.getDevices())[s];if(!t)throw new Error(`No WCH ISP USB device found (4348:55e0 or 1a86:55e0 device not found at index #${s})`);console.debug(`Found USB Device ${t.productName}`),await t.open(),t.configuration===null&&await t.selectConfiguration(1);const n=t.configuration;let r=!1,i=!1;if(n){console.log("config",n);for(const a of n.interfaces){console.log(a);for(const d of a.alternate.endpoints)d.endpointNumber===this.ENDPOINT_OUT&&(r=!0),d.endpointNumber===this.ENDPOINT_IN&&(i=!0)}}if(!(r&&i))throw new Error("USB Endpoints not found");return await t.claimInterface(0),new p(t)}static async openAny(){return this.openNth(0)}async sendRaw(s){await this.device.transferOut(p.ENDPOINT_OUT,s)}async recvRaw(){const s=await this.device.transferIn(p.ENDPOINT_IN,64);if(s.data)return new Uint8Array(s.data.buffer);throw new Error("Failed to receive data")}async recv(){const s=await this.device.transferIn(p.ENDPOINT_IN,64);if(s.data)return D.fromRaw(new Uint8Array(s.data.buffer));throw new Error("Failed to receive data")}};o(p,"ENDPOINT_OUT",2),o(p,"ENDPOINT_IN",2),o(p,"USB_TIMEOUT_MS",5e3),o(p,"MAX_PACKET_SIZE",64),o(p,"SECTOR_SIZE",1024),o(p,"DEFAULT_TRANSPORT_TIMEOUT_MS",1e3);let E=p;class A{constructor(){o(this,"IDENTIFY",161);o(this,"ISP_END",162);o(this,"ISP_KEY",163);o(this,"ERASE",164);o(this,"PROGRAM",165);o(this,"VERIFY",166);o(this,"READ_CONFIG",167);o(this,"WRITE_CONFIG",168);o(this,"DATA_ERASE",169);o(this,"DATA_PROGRAM",170);o(this,"DATA_READ",171);o(this,"WRITE_OTP",195);o(this,"READ_OTP",196);o(this,"SET_BAUD",197)}async pwriteWith(s,e,t,n){if(typeof e=="number")s.setUint32(t,e,n);else for(let r=0;r<e.length;r++)s.setUint8(t+r,e[r]);return s}async ntoRaw(s){switch(s.type){case"Identify":{const{deviceId:e,deviceType:t}=s,n=new Uint8Array(21);return n[0]=this.IDENTIFY,n[1]=18,n[2]=0,n[3]=e,n[4]=t,n.set(new TextEncoder().encode("MCU ISP & WCH.CN"),5),n}case"IspEnd":{const{reason:e}=s;return new Uint8Array([this.ISP_END,1,0,e])}case"IspKey":{const{key:e}=s,t=new Uint8Array(3+e.length);return t[0]=this.ISP_KEY,t[1]=e.length,t[2]=0,t.set(e,3),t}case"Erase":{const{sectors:e}=s,t=new Uint8Array(7);return t[0]=this.ERASE,t[1]=4,t[2]=0,this.pwriteWith(new DataView(t.buffer),e,3,!0),t}case"Program":{const{address:e,padding:t,data:n}=s,r=new Uint8Array(8+n.length),i=new DataView(r.buffer);i.setUint8(0,this.PROGRAM),i.setUint32(3,e,!0),i.setUint8(7,t),r.set(n,8);const a=r.length-3;return i.setUint16(1,a,!0),new Uint8Array(i.buffer)}case"Verify":{const{address:e,padding:t,data:n}=s,r=new Uint8Array(8+n.length);r[0]=this.VERIFY,this.pwriteWith(new DataView(r.buffer),e,3,!0),r[7]=t,r.set(n,8);const i=r.length-3;return this.pwriteWith(new DataView(r.buffer),i,1,!0),r}case"ReadConfig":{const{bitMask:e}=s;return new Uint8Array([this.READ_CONFIG,2,0,e,0])}case"WriteConfig":{const{bitMask:e,data:t}=s,n=new Uint8Array(5+t.length);return n[0]=this.WRITE_CONFIG,this.pwriteWith(new DataView(n.buffer),1+t.length,1,!0),n[3]=e,n.set(t,5),n}case"DataRead":{const{address:e,len:t}=s,n=new Uint8Array(9);return n[0]=this.DATA_READ,n[1]=6,this.pwriteWith(new DataView(n.buffer),e,3,!0),this.pwriteWith(new DataView(n.buffer),t,7,!0),n}case"DataProgram":{const{address:e,padding:t,data:n}=s,r=new Uint8Array(8+n.length);r[0]=this.DATA_PROGRAM,this.pwriteWith(new DataView(r.buffer),e,3,!0),r[7]=t,r.set(n,8);const i=r.length-3;return this.pwriteWith(new DataView(r.buffer),i,1,!0),r}case"DataErase":{const{sectors:e}=s;return new Uint8Array([this.DATA_ERASE,5,0,0,0,0,0,e])}default:throw new Error("Unimplemented command")}}}const v="CH32V00x Series",F="0x11",I="0x21",x=!1,C=!1,T=!0,P="CH32V00x (RISC-V2A) Series",L=[],O=[{name:"CH32V003*4*6",chip_id:51,alt_chip_ids:[50,49,48],flash_size:16384}],U={name:v,mcu_type:F,device_type:I,support_net:x,support_usb:C,support_serial:T,description:P,config_registers:L,variants:O},N="CH32X03x Series",$="0x13",H="0x23",k=!1,W=!0,M=!0,V="CH32X03x RISC-V4C Series",G=[{offset:"0x00",name:"RDPR_USER",description:"RDPR, nRDPR, USER, nUSER",reset:"0xFFFF5AA5",fields:[{bit_range:[7,0],name:"RDPR",description:"Read Protection. 0xA5 for unprotected, otherwise read-protected(ignoring WRP)",explaination:{"0xa5":"Unprotected",_:"Protected"}},{bit_range:[16,16],name:"IWDG_SW",description:"Independent watchdog (IWDG) hardware enable",explaination:{0:"IWDG enabled by the software (decided along with the LSI clock)",1:"IWDG enabled by the software, and disabled by hardware"}},{bit_range:[17,17],name:"STOP_RST",description:"System reset control under the stop mode",explaination:{0:"Enable",1:"Disable"}},{bit_range:[18,18],name:"STANDBY_RST",description:"System reset control under the standby mode, STANDY_RST",explaination:{0:"Enable",1:"Disable, entering standby-mode without RST"}},{bit_range:[20,19],name:"RST_MOD",description:"Reset mode",explaination:{"0b00":"Enable RST alternative function","0b11":"Disable RST alternative function, use PA21/PC3/PB7 as GPIO",_:"Error"}}]},{offset:"0x04",name:"DATA",description:"Customizable 2 byte data, DATA0, nDATA0, DATA1, nDATA1",reset:"0xFF00FF00",type:"u32",fields:[{bit_range:[7,0],name:"DATA0"},{bit_range:[23,16],name:"DATA1"}]},{offset:"0x08",name:"WRP",description:"Flash memory write protection status",type:"u32",reset:"0xFFFFFFFF",explaination:{"0xFFFFFFFF":"Unprotected",_:"Some 4K sections are protected"}}],z=[{name:"CH32X035R8T6",chip_id:80,flash_size:65536},{name:"CH32X035C8T6",chip_id:81,flash_size:65536},{name:"CH32X035F8U6",chip_id:94,flash_size:65536},{name:"CH32X035G8U6",chip_id:86,flash_size:65536},{name:"CH32X035G8R6",chip_id:91,flash_size:65536},{name:"CH32X035F7P6",chip_id:87,flash_size:49152}],B={name:N,mcu_type:$,device_type:H,support_net:k,support_usb:W,support_serial:M,description:V,config_registers:G,variants:z},K="CH59x Series",q="0x12",X="0x22",Y=!0,Z=!0,j=!1,J="CH59x (RISC-V4C BLE 5.4) Series",Q=[{offset:"0x00",name:"RESERVED",description:"Reserved 32-bit word",reset:"0xFFFFFFFF",type:"u32"},{offset:"0x04",name:"WPROTECT",reset:"0xFFFFFFFF",type:"u32",fields:[{bit_range:[0,0],name:"NO_KEY_SERIAL_DOWNLOAD",description:"Turn on No-key serial port download",explaination:{0:"Disable",1:"Enable"}},{bit_range:[1,1],name:"DOWNLOAD_CFG",explaination:{0:"PB11",1:"PB22 (Default set)"}}]},{offset:"0x08",name:"USER_CFG",description:"User config register",reset:"0x4FFF0FD5",type:"u32",fields:[{bit_range:[2,0],name:"RESERVED",explaination:{"0b101":"Default",_:"Error"}},{bit_range:[3,3],name:"CFG_RESET_EN",description:"RST# external manual reset input pin enable",explaination:{0:"Disable",1:"Enable"}},{bit_range:[4,4],name:"CFG_DEBUG_EN",description:"Two-wire simulation debug interface SWD enable",explaination:{0:"Disable",1:"Enable"}},{bit_range:[5,5],name:"RESERVED",explaination:{0:"Default",_:"Error"}},{bit_range:[6,6],name:"CFG_BOOT_EN",description:"Bootloader enable",explaination:{0:"Disable",1:"Enable"}},{bit_range:[7,7],name:"CFG_ROM_READ",description:"Code and data protection mode in FlashROM",explaination:{0:"Disable the programmer to read out, and keep the program secret",1:"Read enable"}},{bit_range:[27,8],name:"RESERVED",explaination:{"0xFF0F":"Default",_:"Error"}},{bit_range:[31,28],name:"VALID_SIG",description:"Configuration information valid flag, fixed value",explaination:{"0b0100":"Valid",_:"Error"}}]}],ee=[{name:"CH591",chip_id:145,flash_size:196608,eeprom_size:32768},{name:"CH592",chip_id:146,flash_size:458752,eeprom_size:32768}],te={name:K,mcu_type:q,device_type:X,support_usb:Y,support_serial:Z,support_net:j,description:J,config_registers:Q,variants:ee},ne="CH643 Series",re="0x14",se="0x24",ie=!1,ae=!0,oe=!0,ce="CH643 RISC-V4C RGB Display Driver Series",de=[{name:"CH643",chip_id:48,alt_chip_ids:["ALL"],flash_size:63488}],ue={name:ne,mcu_type:re,device_type:se,support_net:ie,support_usb:ae,support_serial:oe,description:ce,variants:de},u=class u extends E{constructor(e){super(e);o(this,"SECTOR_SIZE",1024);o(this,"device_type",null);o(this,"chip_id",null);o(this,"chip_uid",new Uint8Array(8));o(this,"code_flash_protected",null);o(this,"btver",new Uint8Array(4));o(this,"flash_size",null);o(this,"protocol",new A)}supportCodeFlashProtect(){return this.device_type?[20,21,23,24,25,32].includes(this.device_type):!1}minEraseSectorNumber(){return this.device_type===16?4:8}xorKey(){if(this.chip_id==null)throw new Error("Chip ID not found");const e=this.chip_uid.reduce((n,r)=>n+r,0)&255,t=new Uint8Array(8).fill(e);return t[7]=t[7]+this.chip_id&255,t}async findDevice(){u.clearLog();const e={type:"Identify",deviceId:0,deviceType:0},t=await this.protocol.ntoRaw(e);this.sendRaw(t);const n=await this.recv();if(n.type=="Err")throw new Error("Error in finding device");this.device_type=n.data[1],this.chip_id=n.data[0];let r;switch(this.device_type){case 33:r=U;break;case 34:r=te;break;case 35:r=B;break;case 36:r=ue;break;default:throw new Error("Device not supported")}r.device_type=="0x"+this.device_type.toString(16)&&u.debugLog("Device Series : "+r.name),r.variants.forEach(l=>{l.chip_id==this.chip_id&&(this.flash_size=l.flash_size,u.debugLog("Chip : "+l.name),u.debugLog("Flash Size : "+l.flash_size/1024+" KiB"))});const i={type:"ReadConfig",bitMask:u.CFG_MASK_ALL},a=await this.protocol.ntoRaw(i);this.sendRaw(a);const d=await this.recv();if(d.type=="Err")throw new Error("Error in finding config");this.code_flash_protected=this.supportCodeFlashProtect()&&d.data[2]!=165,u.debugLog("Code Flash Protected : "+this.code_flash_protected),this.btver.set(d.data.slice(14,18)),u.debugLog("Bootloader Version (BTVER) : "+this.btver[0]+this.btver[1]+"."+this.btver[2]+this.btver[3]),this.chip_uid.set(d.data.slice(18)),u.debugLog("Chip UID : "+Array.from(this.chip_uid).map(l=>l.toString(16).padStart(2,"0").toUpperCase()).join("-")),this.dumpInfo(d,r)}async dumpInfo(e,t){const n=e.data.slice(2);t.config_registers&&t.config_registers.forEach(r=>{let i=new DataView(n.buffer,n.byteOffset+Number(r.offset),4).getUint32(0,!0);u.debugLog(r.name+" : 0x"+i.toString(16)),r.fields&&r.fields.forEach(a=>{let d=a.bit_range[0]-a.bit_range[1]+1,l=i>>>a.bit_range[1]&(1<<d)-1;if(u.debugLog(`[${a.bit_range[0]}, ${a.bit_range[1]}] ${a.name}  0x${l.toString(16)} (0b${l.toString(2)})`),"explaination"in a&&a.explaination)for(const[g,h]of Object.entries(a.explaination))l==Number(g)&&u.debugLog(` - ${h}`)})})}async eraseCode(e){const t={type:"Erase",sectors:e},n=await this.protocol.ntoRaw(t);if(console.log("erase send data",n),this.sendRaw(n),(await this.recv()).type=="Err")throw new Error("Error in erasing code");u.debugLog(`Erased ${e} code flash sectors`)}async eraseFlash(e=this.flash_size){if(this.flash_size||(await this.findDevice(),e=this.flash_size),!e)throw new Error("Flash size not found");let t=e/1024;const n=this.minEraseSectorNumber();t<n&&(t=n,u.debugLog(`erase_code: set min number of erased sectors to ${t}`));const r={type:"Erase",sectors:t},i=await this.protocol.ntoRaw(r);this.sendRaw(i),console.log("erase data",i);const a=await this.recv();if(console.log(a),a.type=="Err")throw new Error("Error in erasing flash");u.debugLog(`Erased ${t} code flash sectors`)}async flashChunk(e,t,n){const r=t.map((g,h)=>g^n[h%8]),i=Math.floor(Math.random()*256),a={type:"Program",address:e,padding:i,data:r},d=await this.protocol.ntoRaw(a);if(await this.sendRaw(d),await this.sleep(300),(await this.recv()).type=="Err")throw new Error(`Program 0x${e.toString(16).padStart(8,"0")} failed`)}extendFirmwareToSectorBoundary(e){const t=[...e];if(t.length%1024!==0){const n=1024-t.length%1024;t.push(...new Array(n).fill(0))}return t}mergeSections(e){e.sort((a,d)=>a.offset-d.offset);const t=e[0].offset,r=e[e.length-1].offset+e[e.length-1].value.length-t,i=new Uint8Array(r);for(const a of e){const d=a.offset-t;i.set(a.value,d)}return i}async readIHex(e){console.log("read intel hex");const t=[];let n=0;const r=e.split(`
`);for(const i of r)if(i.startsWith(":")){const a=this.parseIHexRecord(i);switch(a.type){case"00":const d=n+a.offset;t.push({offset:d,value:a.data});break;case"01":break;case"02":n=a.address*16;break;case"03":break;case"04":n=a.address<<16;break}}return this.mergeSections(t)}parseIHexRecord(e){const t=parseInt(e.substr(1,2),16),n=parseInt(e.substr(3,4),16),r=e.substr(7,2),i=new Uint8Array(t);for(let d=0;d<t;d++)i[d]=parseInt(e.substr(9+d*2,2),16);const a=parseInt(e.substr(9,4),16);return{type:r,offset:n,data:i,address:a}}intelHexToUint8Array(e){const t=e.trim().split(`
`),n=[];return t.forEach(r=>{if(r.startsWith(":")){const i=parseInt(r.substr(1,2),16),a=9,d=a+i*2;for(let l=a;l<d;l+=2)n.push(parseInt(r.substr(l,2),16))}}),new Uint8Array(n)}async flashFirmware(e){const t=await this.readIHex(e),n=t.length/this.SECTOR_SIZE+1;this.flash_size||await this.findDevice(),await this.eraseCode(n),u.debugLog("flashing firmware ...");const r=this.xorKey(),i=r.reduce((w,_)=>w+_&255,0),a={type:"IspKey",key:new Uint8Array(30)},d=await this.protocol.ntoRaw(a);this.sendRaw(d);const l=await this.recv();if(l.type=="Err")throw new Error("isp_key failede");if(l.data[0]!=i)throw new Error("isp_key checksum failed");console.log("res data",l.data);const g=56;let h=0;for(let w=0;w<t.length;w+=g){const _=t.subarray(w,w+g);await this.flashChunk(h,_,r),h+=_.length}await this.flashChunk(h,new Uint8Array,r),u.debugLog("firmware flashed")}async reset(){const e={type:"IspEnd",reason:1},t=await this.protocol.ntoRaw(e);if(this.sendRaw(t),(await this.recv()).type=="Err")throw new Error("Error in reset");u.debugLog("Device Reset")}};o(u,"CFG_MASK_RDPR_USER_DATA_WPR",7),o(u,"CFG_MASK_BTVER",8),o(u,"CFG_MASK_UID",16),o(u,"CFG_MASK_CODE_FLASH_PROTECT",32),o(u,"CFG_MASK_ALL",31);let f=u,y=!1,b,m;const le=[{vendorId:17224,productId:21984},{vendorId:6790,productId:21984}];function pe(c){c.addEventListener("click",()=>{navigator.usb.requestDevice({filters:le}).then(async s=>{b=new f(s),f.openNth(0),f.debugLog("Connected"),y=!y,c.innerHTML="Disconnect"}).catch(s=>{console.error(s),c.innerHTML="Connect"})})}function fe(c){c.addEventListener("click",async()=>{if(!y){f.debugLog("Please Connect First");return}if(!b){f.debugLog("Something went wrong");return}try{await b.findDevice()}catch(s){f.debugLog(s)}})}function he(c){c.addEventListener("click",async()=>{if(!y){f.debugLog("Please Connect First");return}c.innerHTML="Erasing...",await b.eraseFlash(),c.innerHTML="Erase"})}function ge(c){c.addEventListener("click",async()=>{if(!y){f.debugLog("Please Connect First");return}c.innerHTML="Flashing...",await b.flashFirmware(m),c.innerHTML="Flash"})}function we(c){c.addEventListener("click",async()=>{if(!y){f.debugLog("Please Connect First");return}c.innerHTML="Resetting...",await b.reset(),c.innerHTML="Reset"})}function ye(c){return new Promise((s,e)=>{const t=new FileReader;t.onload=()=>s(t.result),t.onerror=e,t.readAsText(c,"utf-8")})}function be(c){c.addEventListener("change",async s=>{const e=s.target.files[0];e&&e.name.endsWith(".hex")?(m=await ye(e),console.log(m)):alert("Please upload a valid .hex file")})}document.querySelector("#app").innerHTML=`
  <div>
      <h1>WCH ISP Web Tool</h1>
      <h3>Suported Series: CH32V00x, CH32X03x, CH59x, CH5643</h3>
      <h4>Supported Browsers: Chrome, Edge</h4>
      <button id="connect" type="button">Connect</button>
      <button id="getInfo" type="button">Get Info</button>
      <label for="myfile">Upload a hex:</label>
      <input type="file" id="myfile" name="myfile" accept=".hex">
      <button id="erase" type="button">Erase</button>
      <button id="flash" type="button">Flash</button>
      <button id="reset" type="button">Reset</button>
      <textarea id="console" rows="15" cols="50" readonly></textarea>
      <p>Note : If you are using Windows, you need to install the WinUSB driver for your device
      <a href="https://zadig.akeo.ie/">see Zadig</a>
      </p>
  </div>
`;pe(document.querySelector("#connect"));he(document.querySelector("#erase"));ge(document.querySelector("#flash"));fe(document.querySelector("#getInfo"));be(document.querySelector("#myfile"));we(document.querySelector("#reset"));
